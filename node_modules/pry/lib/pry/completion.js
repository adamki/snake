(function() {
  var AutoComplete, Compiler,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  Compiler = require('./compiler');

  AutoComplete = (function() {
    var ACCESSOR, KEYWORDS, SIMPLEVAR, THISPROP;

    ACCESSOR = /\s*([\@\w\.]+)(?:\.(\w*))$/;

    THISPROP = /\s*(\@)(\w*)/;

    SIMPLEVAR = /\s*(\w*)$/i;

    KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when', 'require', 'true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'whereami', 'kill!', 'exit', 'wtf', 'play', 'version', 'help'].concat(Object.getOwnPropertyNames(global));

    function AutoComplete(scope, file) {
      this.scope = scope;
      this.file = file;
      this.autocomplete = bind(this.autocomplete, this);
      this.localVars = this.file.getLocalVariables();
      this.compiler = new Compiler({
        scope: this.scope,
        isCoffee: true
      });
    }

    AutoComplete.prototype.autocomplete = function(text) {
      var e;
      try {
        return this.completeAttribute(text) || this.completeVariable(text) || [[], text];
      } catch (_error) {
        e = _error;
        return [[], []];
      }
    };

    AutoComplete.prototype.completeAttribute = function(text) {
      var all, completions, error, match, obj, prefix, val;
      if (match = text.match(ACCESSOR) || text.match(THISPROP)) {
        all = match[0], obj = match[1], prefix = match[2];
        try {
          val = this.compiler.execute(obj);
        } catch (_error) {
          error = _error;
          return [[], text];
        }
        completions = this.getCompletions(prefix, this.getPropertyNames(val));
        return [completions, prefix || ''];
      }
    };

    AutoComplete.prototype.completeVariable = function(text) {
      var free, globalVars, key, ref;
      if (free = (ref = text.match(SIMPLEVAR)) != null ? ref[1] : void 0) {
        globalVars = (function() {
          var results;
          results = [];
          for (key in global) {
            if (!hasProp.call(global, key)) continue;
            if (KEYWORDS.indexOf(key) === -1) {
              results.push(key);
            }
          }
          return results;
        })();
        return [this.getCompletions(free, this.localVars.concat(KEYWORDS, globalVars)), free];
      }
    };

    AutoComplete.prototype.getCompletions = function(prefix, candidates) {
      var el, i, len, results;
      if (prefix) {
        results = [];
        for (i = 0, len = candidates.length; i < len; i++) {
          el = candidates[i];
          if (el.indexOf(prefix) === 0) {
            results.push(el);
          }
        }
        return results;
      } else {
        return candidates;
      }
    };

    AutoComplete.prototype.getPropertyNames = function(obj) {
      var name, props;
      props = (function() {
        var results;
        results = [];
        for (name in obj) {
          if (!hasProp.call(obj, name)) continue;
          results.push(name);
        }
        return results;
      })();
      if (typeof obj === 'string') {
        props = props.concat(Object.getOwnPropertyNames(String.prototype));
      } else if (obj instanceof Array) {
        props = props.concat(Object.getOwnPropertyNames(Array.prototype));
      } else if (obj === Object) {
        props = props.concat(Object.getOwnPropertyNames(Object));
      }
      return props;
    };

    return AutoComplete;

  })();

  module.exports = AutoComplete;

}).call(this);
